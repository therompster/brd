// scripts.js

document.addEventListener('DOMContentLoaded', function () {
    // Initialize Mermaid when the DOM is fully loaded
    mermaid.initialize({
        startOnLoad: false,
        securityLevel: 'loose',
        flowchart: {
            useMaxWidth: true,
            nodeSpacing: 100,
            rankSpacing: 100
        },
        theme: 'default',
    });

    // Attach event listener for the parse button only after DOM is loaded
    const parseButton = document.getElementById("parse-btn");

    if (parseButton) {
        parseButton.addEventListener("click", async function () {
            let brdContent = document.getElementById("brd-content").value;

            if (!brdContent) {
                alert("Please enter some content!");
                return;
            }

            const requestBody = { brd_content: brdContent };

            try {
                const response = await fetch("http://172.18.15.47:5000/api/parse-brd", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify(requestBody),
                });

                const result = await response.json();

                if (response.ok) {
                    const parsedData = result.parsed_data;
                    document.getElementById("result").textContent = JSON.stringify(parsedData, null, 2);

                    // Generate Mermaid syntax
                    const layout = document.querySelector('input[name="layout"]:checked').value;
                    const mermaidSyntax = generateMermaidSyntax(parsedData, layout);
                    document.getElementById("mermaid-syntax").textContent = mermaidSyntax;

                    // Render the Mermaid diagram after ensuring the container is ready
                    renderMermaidDiagram(mermaidSyntax);

                    // Show the "Generate Wireframes" button
                    const generateWireframesBtn = document.getElementById('generate-wireframes-btn');
                    generateWireframesBtn.style.display = 'inline-block';

                    // Store parsedData for later use
                    window.parsedData = parsedData;
                } else {
                    document.getElementById("result").textContent = result.error || "Error processing request.";
                }
            } catch (error) {
                console.error("Fetch error:", error);
                document.getElementById("result").textContent = "Network error. Please try again.";
            }
        });
    }

    // Function to generate Mermaid syntax from parsed data
    function generateMermaidSyntax(parsedData, layout) {
        let mermaidDiagram = `graph ${layout};\n`;

        function sanitizeId(id) {
            return id.replace(/\s+/g, "_").replace(/[^a-zA-Z0-9_]/g, "");
        }

        function sanitizeLabel(label) {
            const maxLength = 50; // Limit label length for readability
            let sanitizedLabel = label.replace(/["<>]/g, function (match) {
                return {
                    '"': '\\"',
                    '<': '&lt;',
                    '>': '&gt;'
                }[match];
            });
            sanitizedLabel = sanitizedLabel.replace(/\n/g, ' '); // Remove newlines
            return sanitizedLabel.length > maxLength ? sanitizedLabel.substring(0, maxLength) + '...' : sanitizedLabel;
        }

        function processNode(parentId, key, value) {
            const nodeId = sanitizeId(`${parentId}_${key}`);

            if (Array.isArray(value)) {
                value.forEach((item, index) => {
                    const arrayNodeId = sanitizeId(`${nodeId}_${index}`);
                    const label = typeof item === "object" ? `${key} ${index + 1}` : item;
                    mermaidDiagram += `${nodeId} --> ${arrayNodeId}["${sanitizeLabel(label)}"];\n`;

                    if (typeof item === "object") {
                        Object.entries(item).forEach(([subKey, subValue]) => {
                            processNode(arrayNodeId, subKey, subValue);
                        });
                    }
                });
            } else if (typeof value === "object" && value !== null) {
                mermaidDiagram += `${parentId} --> ${nodeId}["${sanitizeLabel(key)}"];\n`;
                Object.entries(value).forEach(([subKey, subValue]) => {
                    processNode(nodeId, subKey, subValue);
                });
            } else {
                mermaidDiagram += `${parentId} --> ${nodeId}["${sanitizeLabel(value)}"];\n`;
            }
        }

        // Root node
        const rootId = "root";
        mermaidDiagram += `${rootId}["BRD"];\n`;

        Object.entries(parsedData).forEach(([key, value]) => {
            const sectionId = sanitizeId(`section_${key}`);
            mermaidDiagram += `${rootId} --> ${sectionId}["${sanitizeLabel(key)}"];\n`;

            if (typeof value === "object" && value !== null) {
                Object.entries(value).forEach(([subKey, subValue]) => {
                    processNode(sectionId, subKey, subValue);
                });
            }
        });

        return mermaidDiagram;
    }

    // Function to render the Mermaid diagram
    function renderMermaidDiagram(mermaidSyntax) {
        const diagramContainer = document.getElementById("mermaid-diagram");

        if (diagramContainer) {
            // Clear any previous diagram
            diagramContainer.innerHTML = '';

            mermaid.render('generatedDiagram', mermaidSyntax)
                .then(({ svg, bindFunctions }) => {
                    diagramContainer.innerHTML = svg;

                    // If there are any event handlers to bind (for interactions)
                    if (bindFunctions) {
                        bindFunctions(diagramContainer);
                    }
                })
                .catch((error) => {
                    console.error('Mermaid render error:', error);
                    diagramContainer.innerHTML = '<p>Error rendering diagram</p>';
                });
        }
    }

    // Attach event listener for the "Generate Wireframes" button
    const generateWireframesBtn = document.getElementById('generate-wireframes-btn');

    if (generateWireframesBtn) {
        generateWireframesBtn.addEventListener('click', async function () {
            const parsedData = window.parsedData;

            try {
                const response = await fetch("http://172.18.15.47:5000/api/generate-wireframes", {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ parsed_data: parsedData })
                });

                const result = await response.json();

                if (response.ok) {
                    // Display wireframes
                    document.getElementById('wireframes-heading').style.display = 'block';
                    window.wireframeData = result.wireframes; // Store for later use

                    // Render wireframes using Konva.js
                    renderWireframes(result.wireframes);

                    // Show the "Generate Code" button
                    const generateCodeBtn = document.getElementById('generate-code-btn');
                    generateCodeBtn.style.display = 'inline-block';
                } else {
                    console.error(result.error);
                }
            } catch (error) {
                console.error('Error generating wireframes:', error);
            }
        });
    }

    // Function to render wireframes using Konva.js
    function renderWireframes(wireframes) {
        const wireframesContainer = document.getElementById('wireframes-container');
        wireframesContainer.innerHTML = '';

        wireframes.forEach((wireframe, index) => {
            const wireframeDiv = document.createElement('div');
            wireframeDiv.classList.add('wireframe');

            const title = document.createElement('h3');
            title.textContent = `Wireframe for: ${wireframe.screenName}`;
            wireframeDiv.appendChild(title);

            // Create a container for the canvas
            const canvasContainer = document.createElement('div');
            canvasContainer.id = `canvas-container-${index}`;
            canvasContainer.style.width = '800px';
            canvasContainer.style.height = '600px';
            canvasContainer.style.border = '1px solid #ccc';
            wireframeDiv.appendChild(canvasContainer);

            wireframesContainer.appendChild(wireframeDiv);

            // Initialize Konva Stage
            const stage = new Konva.Stage({
                container: canvasContainer.id,
                width: 800,
                height: 600,
            });

            const layer = new Konva.Layer();
            stage.add(layer);

            try {
                const wireframeData = JSON.parse(wireframe.wireframeDescription);
                const components = wireframeData.components;

                components.forEach((component) => {
                    renderComponent(component, layer);
                });
            } catch (e) {
                console.error('Error parsing wireframe JSON:', e);
                const errorMsg = document.createElement('p');
                errorMsg.textContent = 'Error parsing wireframe JSON.';
                wireframeDiv.appendChild(errorMsg);
            }
        });
    }

    // Function to render individual components using Konva.js
    function renderComponent(component, layer) {
        let konvaElement;

        // Default styles
        const defaultStyles = {
            fill: component.styles?.backgroundColor || 'transparent',
            stroke: component.styles?.borderColor || 'black',
            strokeWidth: component.styles?.borderWidth || 1,
        };

        // Determine position and size
        const position = {
            x: component.position?.x || 0,
            y: component.position?.y || 0,
        };

        const size = {
            width: parseInt(component.size?.width) || 100,
            height: parseInt(component.size?.height) || 50,
        };

        switch (component.componentType.toLowerCase()) {
            case 'text':
                konvaElement = new Konva.Text({
                    x: position.x,
                    y: position.y,
                    text: component.content || '',
                    fontSize: component.styles?.fontSize || 16,
                    fontFamily: component.styles?.fontFamily || 'Arial',
                    fill: component.styles?.color || 'black',
                    fontStyle: component.styles?.fontWeight || 'normal',
                });
                break;
            case 'image':
                konvaElement = new Konva.Rect({
                    x: position.x,
                    y: position.y,
                    width: size.width,
                    height: size.height,
                    ...defaultStyles,
                    fillPatternImage: null, // Will set later if image is valid
                });
                // Load image
                if (component.content && isValidURL(component.content)) {
                    const imageObj = new Image();
                    imageObj.onload = function () {
                        konvaElement.fillPatternImage(imageObj);
                        konvaElement.fillPatternScale({
                            x: size.width / imageObj.width,
                            y: size.height / imageObj.height,
                        });
                        layer.draw();
                    };
                    imageObj.src = component.content;
                } else {
                    // Use placeholder image
                    const imageObj = new Image();
                    imageObj.onload = function () {
                        konvaElement.fillPatternImage(imageObj);
                        konvaElement.fillPatternScale({
                            x: size.width / imageObj.width,
                            y: size.height / imageObj.height,
                        });
                        layer.draw();
                    };
                    imageObj.src = 'https://via.placeholder.com/150';
                }
                break;
            case 'button':
                konvaElement = new Konva.Rect({
                    x: position.x,
                    y: position.y,
                    width: size.width,
                    height: size.height,
                    cornerRadius: 5,
                    fill: component.styles?.backgroundColor || '#007BFF',
                    stroke: component.styles?.borderColor || 'black',
                    strokeWidth: component.styles?.borderWidth || 1,
                });
                // Add button text
                const buttonText = new Konva.Text({
                    x: position.x + size.width / 2,
                    y: position.y + size.height / 2,
                    text: component.content || 'Button',
                    fontSize: component.styles?.fontSize || 16,
                    fontFamily: component.styles?.fontFamily || 'Arial',
                    fill: component.styles?.color || 'white',
                });
                buttonText.offsetX(buttonText.width() / 2);
                buttonText.offsetY(buttonText.height() / 2);
                layer.add(konvaElement, buttonText);
                layer.draw();
                return;
            // Add more component types as needed
            default:
                // For unknown component types, draw a rectangle with text
                konvaElement = new Konva.Rect({
                    x: position.x,
                    y: position.y,
                    width: size.width,
                    height: size.height,
                    ...defaultStyles,
                });
                const defaultText = new Konva.Text({
                    x: position.x + 5,
                    y: position.y + 5,
                    text: component.componentType,
                    fontSize: 12,
                    fill: 'black',
                });
                layer.add(konvaElement, defaultText);
                layer.draw();
                return;
        }

        layer.add(konvaElement);
        layer.draw();
    }

    // Helper function to validate URLs
    function isValidURL(string) {
        try {
            new URL(string);
            return true;
        } catch (_) {
            return false;
        }
    }

    // Attach event listener for the "Generate Code" button
    const generateCodeBtn = document.getElementById('generate-code-btn');

    if (generateCodeBtn) {
        generateCodeBtn.addEventListener('click', async function () {
            const wireframeData = window.wireframeData;

            try {
                const response = await fetch("http://172.18.15.47:5000/api/generate-code", {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ wireframe_data: wireframeData })
                });

                const result = await response.json();

                if (response.ok) {
                    // Display generated code
                    const codeContainer = document.getElementById('generated-code-container');
                    codeContainer.innerHTML = '';
                    document.getElementById('generated-code-heading').style.display = 'block';

                    result.generated_code.forEach(screen => {
                        const screenDiv = document.createElement('div');
                        screenDiv.classList.add('screen-section');

                        const title = document.createElement('h3');
                        title.textContent = `Code for: ${screen.screenName}`;
                        screenDiv.appendChild(title);

                        const codePre = document.createElement('pre');
                        codePre.textContent = screen.code;
                        screenDiv.appendChild(codePre);

                        // Render the code in an iframe
                        const iframe = document.createElement('iframe');
                        iframe.style.width = '100%';
                        iframe.style.height = '600px';
                        iframe.style.border = '1px solid #ccc';

                        // Ensure the code is a complete HTML document
                        let code = screen.code;

                        // Remove any Markdown code blocks or backticks
                        code = code.replace(/```html|```css|```/g, '');

                        // Create a Blob from the code
                        const blob = new Blob([code], { type: 'text/html' });
                        const url = URL.createObjectURL(blob);

                        iframe.src = url;
                        screenDiv.appendChild(iframe);

                        codeContainer.appendChild(screenDiv);
                    });
                } else {
                    console.error(result.error);
                }
            } catch (error) {
                console.error('Error generating code:', error);
            }
        });
    }
});

